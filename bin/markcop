#!/bin/bash
#
# -----------------
# =    MARKCOP    =
# -----------------
#
# Markcop is your one-stop shop for Markdown enforcing.
#
# This script iterates through all of the .md files in `git ls-files` and checks
# that everything follows our markdown style guidelines at
# https://github.com/hackedu/meta/blob/master/markdown_style_guide.md
#
# It's still pretty janky, and will probably only work on Linux machines. If you
# run into any issues or have any comments/questions/concerns, please file an
# issue!

URL_REGEX='(https?|ftp|file)://[-A-Za-z0-9\+&@#/%?=~_|!:,.;]*[-A-Za-z0-9\+&@#/%=~_|]'
HAS_ERROR=false
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m'
IFS='
'

errors=''

function trailing_whitespace {
  file_name="$1"
  trailing_whitespace_errors_in_file=false
  trailing_whitespace_regex='^.+\s{3,}$'
  for line in $(echo "$2" | grep -oP $trailing_whitespace_regex | sed -e 's/:/\t/'); do
    trailing_whitespace_errors_in_file=true
    line_num=$(echo "$line" | cut -f1)
    line_contents=$(echo $line | cut -f2)
    errors="$errors\n$line_num:$file_name has trailing whitespace!"
  done

  if [ $trailing_whitespace_errors_in_file = true ]; then
    return 1
  fi

  return 0
}

function malformed_header {
  file_name="$1"
  malformed_header_in_file=false
  for line in $(echo "$2" | grep -oP '^[0-9]+:#[^\{]*$' | sed -e 's/:/\t/'); do
    line_num=$(echo "$line" | cut -f1)
    line_contents=$(echo $line | cut -f2)
    # Check that there is a space between the # and the header
    header_missing_space_after_hashtag_regex='^\#{1,6}[^\ \#].*$'
    if [[ "$line_contents" =~ $header_missing_space_after_hashtag_regex ]]; then
      malformed_header_in_file=true
      errors="$errors\n$line_num:$file_name doesn't have a space between the # and the text of the header!"
    fi
    # Check to see if a header is indented over 6 levels
    header_indented_over_6_levels_regex='^\#{7,}.*$'
    if [[ "$line_contents" =~ $header_indented_over_6_levels_regex ]]; then
      malformed_header_in_file=true
      errors="$errors\n$line_num:$file_name is a header indented more than 6 levels!"
    fi
    # Check that the header doesn't end with a closing #
    header_ending_with_hashtag_regex='^.+\#[\ ]*$'
    if [[ "$line_contents" =~ $header_ending_with_hashtag_regex ]]; then
      malformed_header_in_file=true
      errors="$errors\n$line_num:$file_name is a header with a closing #!"
    fi
  done

  if [ $malformed_header_in_file = true ]; then
    return 1
  fi

  return 0
}

function long_line {
  file_name="$1"
  long_line_in_file=false
  for line in $(echo "$2" | grep -oP '^[0-9]+:[^\|].{80,}[^\|]$' | sed -e 's/:/\t/'); do
    # Check to make sure the line doesn't contain a link or HTML comment
    html_comment_regex='^\<!--.*--\>$'
    markdown_link_at_end_of_line_regex='\[.*\]\(.*\)\W*$'
    if [[ ! $line_contents =~ $URL_REGEX && ! $line_contents =~ $html_comment_regex && ! $line_contents =~ $markdown_link_at_end_of_line_regex ]]; then
      line_num=$(echo "$line" | cut -f1)
      long_line_in_file=true
      errors="$errors\n$line_num:$file_name is over 80 chars!"
    fi
  done

  if [ $long_line_in_file = true ]; then
    return 1
  fi

  return 0
}

function missing_link {
  file_name="$1"
  for line in $(echo "$2" | grep -oP '[0-9]+:\[.*\]\(.*?(?=\))'); do
    line_num=$(echo $line | cut -f1)
    dir=$(dirname "$file_name")
    link_dest=$(echo $line | grep -oP '\[.*\]\(\K.*')
    broken_link=true

    # Only check if the link is not a URL and if it's not empty
    if [[ ( ! $link_dest =~ $URL_REGEX ) ]]; then
      link_dest_file=$(echo $link_dest | sed "s/#.*$//") # 'file.md' <- 'file.md#heading'
      link_dest_heading=$(echo $link_dest | grep -o '#.*$') # '#heading' <- 'file.md#heading'
      linked_path=$(readlink -f "$dir/$link_dest_file") # '/home/user/proj/file.md'

      # If there's no link_dest_heading (the '#heading' part of 'file.md#heading')
      if [[ -z "$link_dest_heading" ]]; then
        # Check if the linked path is either an existing file or directory
        if [[ ( -f "$linked_path" ) || ( -d "$linked_path" ) ]]; then
          broken_link=false
        fi
      else
        file_to_check=$file_name

        # '#my-heading' -> 'my heading'
        stripped_heading=$(echo $link_dest_heading | sed -e 's/#//' -e 's/-/ /g')

        # If there's a filename in the link (the 'file.md' part of 'file.md#heading')
        if [[ ! -z "$link_dest_file" ]]; then
          file_to_check=$linked_path
        fi

        for match in $(
                      cat $file_to_check |
                        grep -i "^#\+" | # only headings
                        sed 's/-/ /g' | # replace dashes with spaces
                        tr -d '[:punct:]' | # remove all punctuation
                        sed -e 's/^ \+//' -e 's/ \+$//' -e 's/  \+/ /g' | # strip extra spaces
                        grep -io "^$stripped_heading\$"
                    ); do
          broken_link=false
        done
      fi
    else # if the link is a URL
      broken_link=false
    fi

    if [ $broken_link = true ]; then
      errors="${errors}\n${line_num}:${file} '${link_dest}' is not a valid link!"
    fi
  done
}

for file in $(git ls-files | grep '\.md$'); do
  content=$(grep -n "" $file)
  # $content is in the format file:line_number:line
  trailing_whitespace "$file" "$content"
  malformed_header "$file" "$content"
  long_line "$file" "$content"
  missing_link "$file" "$content"
done

>&2 printf "\n\n$errors\n"

if [ ! -n "$error" ]; then
  exit 1
fi
